/**
 * @license
 * Copyright Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
import { jsonTokenTypeToString, tokenize, } from './tokenize.js';
/**
 * Incrementally parses a single JSON value from the given iterable of string
 * chunks.
 *
 * Yields a sequence of increasingly complete JSON values as more of the input
 * can be parsed. The final value yielded will be the same as running JSON.parse
 * on the entire input as a single string. If the input is not valid JSON,
 * throws an error in the same way that JSON.parse would, though the error
 * message is not guaranteed to be the same.
 *
 * When possible (i.e. with objects and arrays), the yielded JSON values will
 * be reused. This means that if you store a reference to a yielded value, it
 * will be updated in place as more of the input is parsed.
 *
 * As with JSON.parse, this throws if non-whitespace trailing content is found.
 *
 * For performance, it parses as much of the string that's synchronously
 * available before yielding. So the sequence of partially-complete values
 * that you'll see will vary based on how the input is grouped into stream
 * chunks.
 *
 * The following invariants will also be maintained:
 *
 * 1. Future versions of a value will have the same type. i.e. we will never
 *    yield a value as a string and then later replace it with an array.
 * 2. true, false, null, and numbers are atomic, we don't yield them until
 *    we have the entire value.
 * 3. Strings may be replaced with a longer string, with more characters (in
 *    the JavaScript sense) appended.
 * 4. Arrays are only modified by either appending new elements, or
 *    replacing/mutating the element currently at the end.
 * 5. Objects are only modified by either adding new properties, or
 *    replacing/mutating the most recently added property.
 * 6. As a consequence of 1 and 5, we only add a property to an object once we
 *    have the entire key and enough of the value to know that value's type.
 */
export async function* parse(stream) {
    yield* new Parser(stream);
}
class Parser {
    stateStack = [
        { type: 0 /* StateEnum.Initial */, value: undefined },
    ];
    toplevelValue;
    tokenizer;
    finished = false;
    progressed = false;
    constructor(textStream) {
        this.tokenizer = tokenize(textStream, this);
    }
    async next() {
        if (this.finished) {
            return { done: true, value: undefined };
        }
        while (true) {
            this.progressed = false;
            await this.tokenizer.pump();
            if (this.toplevelValue === undefined) {
                throw new Error('Internal error: toplevelValue should not be undefined after at least one call to pump()');
            }
            if (this.progressed) {
                return { done: false, value: this.toplevelValue };
            }
            if (this.stateStack.length === 0) {
                await this.tokenizer.pump();
                this.finished = true;
                return { done: true, value: undefined };
            }
        }
    }
    [Symbol.asyncIterator]() {
        return this;
    }
    handleNull() {
        this.handleValueToken(0 /* JsonTokenType.Null */, undefined);
    }
    handleBoolean(value) {
        this.handleValueToken(1 /* JsonTokenType.Boolean */, value);
    }
    handleNumber(value) {
        this.handleValueToken(2 /* JsonTokenType.Number */, value);
    }
    handleStringStart() {
        const state = this.currentState();
        if (!this.progressed && state.type !== 3 /* StateEnum.InObjectExpectingKey */) {
            this.progressed = true;
        }
        switch (state.type) {
            case 0 /* StateEnum.Initial */:
                this.stateStack.pop();
                this.toplevelValue = this.progressValue(3 /* JsonTokenType.StringStart */, undefined);
                break;
            case 2 /* StateEnum.InArray */: {
                const v = this.progressValue(3 /* JsonTokenType.StringStart */, undefined);
                state.value.push(v);
                break;
            }
            case 3 /* StateEnum.InObjectExpectingKey */:
                this.stateStack.push({ type: 1 /* StateEnum.InString */, value: '' });
                break;
            case 4 /* StateEnum.InObjectExpectingValue */: {
                const [key, object] = state.value;
                const sv = this.progressValue(3 /* JsonTokenType.StringStart */, undefined);
                object[key] = sv;
                break;
            }
            case 1 /* StateEnum.InString */:
                throw new Error(`Unexpected ${jsonTokenTypeToString(3 /* JsonTokenType.StringStart */)} token in the middle of string starting ${JSON.stringify(state.value)}`);
        }
    }
    handleStringMiddle(value) {
        const state = this.currentState();
        if (!this.progressed) {
            const prev = this.stateStack[this.stateStack.length - 2];
            if (prev?.type !== 3 /* StateEnum.InObjectExpectingKey */) {
                this.progressed = true;
            }
        }
        if (state.type !== 1 /* StateEnum.InString */) {
            throw new Error(`Unexpected ${jsonTokenTypeToString(4 /* JsonTokenType.StringMiddle */)} token in the middle of string starting ${JSON.stringify(state.value)}`);
        }
        state.value += value;
        const parentState = this.stateStack[this.stateStack.length - 2];
        this.updateStringParent(state.value, parentState);
    }
    handleStringEnd() {
        const state = this.currentState();
        if (state.type !== 1 /* StateEnum.InString */) {
            throw new Error(`Unexpected ${jsonTokenTypeToString(5 /* JsonTokenType.StringEnd */)} token in the middle of string starting ${JSON.stringify(state.value)}`);
        }
        this.stateStack.pop();
        const parentState = this.stateStack[this.stateStack.length - 1];
        this.updateStringParent(state.value, parentState);
    }
    handleArrayStart() {
        this.handleValueToken(6 /* JsonTokenType.ArrayStart */, undefined);
    }
    handleArrayEnd() {
        const state = this.currentState();
        if (state.type !== 2 /* StateEnum.InArray */) {
            throw new Error(`Unexpected ${jsonTokenTypeToString(7 /* JsonTokenType.ArrayEnd */)} token`);
        }
        this.stateStack.pop();
    }
    handleObjectStart() {
        this.handleValueToken(8 /* JsonTokenType.ObjectStart */, undefined);
    }
    handleObjectEnd() {
        const state = this.currentState();
        switch (state.type) {
            case 3 /* StateEnum.InObjectExpectingKey */:
            case 4 /* StateEnum.InObjectExpectingValue */:
                this.stateStack.pop();
                break;
            default:
                throw new Error(`Unexpected ${jsonTokenTypeToString(9 /* JsonTokenType.ObjectEnd */)} token`);
        }
    }
    currentState() {
        const state = this.stateStack[this.stateStack.length - 1];
        if (state === undefined) {
            throw new Error('Unexpected trailing input');
        }
        return state;
    }
    handleValueToken(type, value) {
        const state = this.currentState();
        if (!this.progressed) {
            this.progressed = true;
        }
        switch (state.type) {
            case 0 /* StateEnum.Initial */:
                this.stateStack.pop();
                this.toplevelValue = this.progressValue(type, value);
                break;
            case 2 /* StateEnum.InArray */: {
                const v = this.progressValue(type, value);
                state.value.push(v);
                break;
            }
            case 4 /* StateEnum.InObjectExpectingValue */: {
                const [key, object] = state.value;
                if (type !== 3 /* JsonTokenType.StringStart */) {
                    this.stateStack.pop();
                    this.stateStack.push({
                        type: 3 /* StateEnum.InObjectExpectingKey */,
                        value: object,
                    });
                }
                const v = this.progressValue(type, value);
                object[key] = v;
                break;
            }
            case 1 /* StateEnum.InString */:
                throw new Error(`Unexpected ${jsonTokenTypeToString(type)} token in the middle of string starting ${JSON.stringify(state.value)}`);
            case 3 /* StateEnum.InObjectExpectingKey */:
                throw new Error(`Unexpected ${jsonTokenTypeToString(type)} token in the middle of object expecting key`);
        }
    }
    updateStringParent(updated, parentState) {
        switch (parentState?.type) {
            case undefined:
                this.toplevelValue = updated;
                break;
            case 2 /* StateEnum.InArray */:
                parentState.value[parentState.value.length - 1] = updated;
                break;
            case 4 /* StateEnum.InObjectExpectingValue */: {
                const [key, object] = parentState.value;
                object[key] = updated;
                if (this.stateStack[this.stateStack.length - 1] === parentState) {
                    this.stateStack.pop();
                    this.stateStack.push({
                        type: 3 /* StateEnum.InObjectExpectingKey */,
                        value: object,
                    });
                }
                break;
            }
            case 3 /* StateEnum.InObjectExpectingKey */:
                if (this.stateStack[this.stateStack.length - 1] === parentState) {
                    this.stateStack.pop();
                    this.stateStack.push({
                        type: 4 /* StateEnum.InObjectExpectingValue */,
                        value: [updated, parentState.value],
                    });
                }
                break;
            default:
                throw new Error('Unexpected parent state for string: ' + parentState?.type);
        }
    }
    progressValue(type, value) {
        switch (type) {
            case 0 /* JsonTokenType.Null */:
                return null;
            case 1 /* JsonTokenType.Boolean */:
                return value;
            case 2 /* JsonTokenType.Number */:
                return value;
            case 3 /* JsonTokenType.StringStart */: {
                const state = { type: 1 /* StateEnum.InString */, value: '' };
                this.stateStack.push(state);
                return '';
            }
            case 6 /* JsonTokenType.ArrayStart */: {
                const state = { type: 2 /* StateEnum.InArray */, value: [] };
                this.stateStack.push(state);
                return state.value;
            }
            case 8 /* JsonTokenType.ObjectStart */: {
                const state = {
                    type: 3 /* StateEnum.InObjectExpectingKey */,
                    value: {},
                };
                this.stateStack.push(state);
                return state.value;
            }
            default:
                throw new Error('Unexpected token type: ' + jsonTokenTypeToString(type));
        }
    }
}
//# sourceMappingURL=parse.js.map